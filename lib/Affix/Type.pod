=encoding utf-8

=head1 NAME

Affix::Type - Affix's Advisory Type System

=head1 Introduction

This module provides an advisory type system for Perl, inspired by libraries like L<Type::Tiny>. It allows developers
to express intended data types for variables and function arguments, improving code readability and maintainability.
While Perl itself is dynamically typed, these annotations serve as a guide for L<Affix> and can be used by static
analysis tools to detect potential type mismatches.

The system supports a range of basic types including C<Char>, C<Int>, C<Long>, C<Double>, and more, corresponding to
standard C data types. Additionally, it offers a composite C<Pointer> type to represent memory addresses. This type can
take an optional second argument specifying the number of elements the pointer points to. For instance, C<Pointer[Int,
1]> denotes a pointer to a single integer, while C<Pointer[Int, 5]> indicates a pointer to an array of five integers.
If the second argument is omitted, the return values of this type are blessed to a generic L<Affix::Pointer> objects.
Similarly, C<Struct[...]> allows defining the structure of custom C structs by listing their member types within the
brackets. These annotations provide a clear and concise way to document expected data formats, promoting better code
understanding and reducing the risk of type-related errors.

=head1 Fundamental Types

The core of this system lies in its support for fundamental types that mirror those found in C. These include C<Char>
for storing single characters, C<Int> for whole numbers, C<Long> and C<LongLong> for larger integers, C<Double> and
C<Float> for floating-point numbers, and C<ULong> for unsigned long integers. Additionally, types like C<Char> and
C<Int> are well-suited for representing textual data (e.g., ASCII codes) and numerical calculations, respectively.
C<Double> and C<Float> are ideal for scientific computations requiring decimal precision, while C<ULong> can be useful
for situations where negative values are not expected. By explicitly declaring these types, developers can make their
code's intent clearer and identify potential issues early on, such as attempting arithmetic operations on a string
variable.

Given sizes are minimums measured in bits.

=head2 C<Void>

The C<Void> type corresponds to the C C<void> type. It is generally found in opaque pointers representing the
equivalent to the C<void *> in C.

    affix undef, 'malloc', [Size_t] => Pointer[ Void ];
    my $data = malloc( 32 );

As the example above shows, it's represented by a parameterized C<Pointer[ ... ]> type, using as parameter whatever the
original pointer is pointing to (in this case, C<void>). Here, we're representing native pointers.

As a side effect of it being a no-op in parameter lists, you may use a C<Void> to skip a passed argument.

=head2 C<Bool>

Boolean type may only have room for one of two values: C<true> or C<false>.

Perl considers the number zero, empty strings, the special value C<undef>, and the
L<builtin::false|https://perldoc.perl.org/builtin#false> to all be false. All other values including
L<builtin::true|https://perldoc.perl.org/builtin#true> are considered true.

To explicitly convert a value to a simple boolean (true or false), you can use the logical negation operator (C<!>)
twice, written as C<!!$value>. This coerces the expression into a boolean result.

=head2 C<Char>

It's guaranteed to have a width of at least 8 bits and represents a single character, typically an ASCII code (C<0 ..
127>).

Useful for storing textual data or performing character-level operations.

=head2 C<UChar>

Unsigned version of C<Char>, guaranteed to have a width of at least 8 bits and represents a single character in the
range of C<0 .. 255>.

Suitable for byte manipulation or working in raw binary data.

=head2 C<WChar>

Represents a wide character, capable of storing characters beyond the basic ASCII range.

This allows for working with languages that use alphabets outside the standard 7-bit ASCII set (e.g., Cyrillic, Kanji).

The specific size and encoding of C<WChar> can vary depending on the system, but it's  typically at least 16 bits.

=head2 C<Short>

Signed integer guaranteed to have a width of at least 16 bits in the range of C<-32_768 .. 32_767>.

Can be used for representing small whole numbers or memory offsets where the full range of an C<Int> is not required.

=head2 C<UShort>

Unsigned counterpart of C<Short>, holding values from C<0 ..  65_535> range.

Useful for calculations involving non-negative integers or working with memory addresses, pixel values, etc.

=head2 C<Int>

Represents a signed integer, with the specific range depending on the system architecture (typically 32 or 64 bits).

Commonly used for general-purpose integer calculations.

=head2 C<UInt>

Unsigned version of C<Int>, allowing positive values within the same system-specific range.

Useful for calculations where negative values are not expected or for representing bit fields.

=head2 C<Size_t>

An unsigned integer type specifically designed to hold the size of objects in memory.

Used with functions like C<sizeof> and memory allocation functions like C<malloc>.  The actual size of C<Size_t> can
vary depending on the system architecture, but it's  guaranteed to be large enough to represent any object size.

=head2 C<Long>

Signed integer type, typically offering a larger range than C<Int> (often 32 bits on 64-bit systems).

Can be used for storing larger whole numbers or for compatibility with older code.

=head2 C<ULong>

Unsigned counterpart of C<Long>, holding non-negative values within the same larger range.

Suitable for calculations involving very large positive integers.

=head2 C<LongLong>

Signed integer type with an even larger range than C<LongC> (usually 64 bits).

Ideal for storing very large whole numbers or precise calculations.

=head2 C<ULongLong>

Unsigned version of C<LongLong>, allowing positive values in the extended range.

Useful for representing extremely large non-negative integers.

=head2 C<Float>

Stores L<single-precision floating-point type|https://en.wikipedia.org/wiki/Single-precision_floating-point_format>
numbers, offering a balance between precision and memory usage.

Useful for scientific calculations or representing real-world values that don't require extremely high precision (e.g.,
scientific measurements, financial calculations).

Be aware that floating-point calculations can introduce small rounding errors due to their limited precision.

=head2 C<Double>

Represents  L<double precision floating-point
type|https://en.wikipedia.org/wiki/Double-precision_floating-point_format> numbers, providing a higher degree of
precision compared to C<Float>.

Ideal for situations where high accuracy is critical, such as complex scientific computations or financial modeling.

However, C<Double> uses more memory than C<Float>, so choose it only when the extra precision is necessary.

=head2 Parameterized Types

Some types must be provided with more context data.

=head2 C<Pointer[ ... ]>

Represents a memory address that points to another variable.

The Pointer type can optionally take a second argument specifying the number of elements the pointer points to:

=over

=item C<Pointer[TYPE]>: A pointer to a single element of a given 'TYPE'. 

C<Pointer[Char]> is equivalent to C<char *> in C. This is a special case where, even without the length, we can use a
NULL to signal the end of the given pointer's contents.

C<Pointer[Int]> is equivalent to an C<int*> in C, a pointer to a single integer.

C<Pointer[ Struct[ year => Int, balance => Float] ]> represents a pointer to a custom C struct containing an integer
and a float member.

=item C<Pointer[TYPE, N]>: A pointer to an array of 'N' elements of a given 'TYPE'.

C<Pointer[Char, 10]> is similar to C<char*> in C, but explicitly indicates a pointer to a 10-character array similar to
C<char name[10]> would in C.

C<Pointer[Int, 5]> is equivalent to an C<int*> in C, but advises Affix to handle the pointer as a list of 5 integers.

C<Pointer[ Struct[ year => Int, balance => Float], 20 ]> represents a list of such C structs.

=back

If the number of elements is omitted, treatment of such pointers will typically default to a generic L<Affix::Pointer>
object. This is similar to a raw pointer in C and requires caution when dereferencing, as it  doesn't provide enough
information about the data type it points to.

=head2 C<Struct[ ... ]>

Represents a custom C struct, allowing you to define the structure of the data it holds. By using C<Struct[...]>, you
can clearly document the expected layout of custom C  structs within your Perl code, improving readability and
maintainability.

The C<Struct[...]> type takes a list of key-value pairs within the brackets, where:

=over

=item The key is the name of the member within the struct.

=item The value specifies the type of the member using the defined basic types such as C<Int> or C<Float> or other composite types like C<Pointer[...]> or even nested C<Struct[...]> types.

=back

These are equivalent in Affix's type system and C:

    Struct[                         struct {
        dob => Struct[                  struct { // No one would represent a date like this but...
            year  => UInt,                  unsigned int year;
            month => char,                  char month;
            day   => Char                   char day;
        ],                              } dob;
        name => Pointer[Char]           char *name;
        wId  => Long                    long wId;
    ];                              };

A struct consists of a sequence of members with storage allocated in an ordered sequence (as opposed to C<Union>, which
is a type consisting of a sequence of members where storage overlaps). The order matters!

=head2 C<Union[ ... ]>

A union is a type consisting of a sequence of members with overlapping storage (as opposed to C<Struct>, which is a
type consisting of a sequence of members whose storage is allocated in an ordered sequence).

The value of at most one of the members can be stored in a union at any one time and the union is only as big as
necessary to hold its largest member (additional unnamed trailing padding may also be added). The other members are
allocated in the same bytes as part of that largest member.

A C union that looks like this:

    union {
        char  c[5];
        float f;
    };

...would be defined this way:

    Union[
        c => Array[Char, 5],
        f => Float
    ];

=head2 C<CodeRef[ ... ]>

A value where C<ref($value)> equals C<CODE>. This would be how CodeRefs are defined.

The argument list and return value must be defined. For example, C<CodeRef[[Int, Int]=>Int]> ~~ C<typedef int
(*fuc)(int a, int b);>; that is to say our function accepts two integers and returns an integer.

    CodeRef[[] => Void];                   # typedef void (*function)();
    CodeRef[[Pointer[Int]] => Int];        # typedef Int (*function)(int * a);
    CodeRef[[Str, Int] => Struct[...]];    # typedef struct Person (*function)(chat * name, int age);

=head2 C<InstanceOf[ ... ]>

    InstanceOf['Some::Class']

A blessed object of a certain type. When used as an lvalue, the result is properly blessed. As an rvalue, the reference
is checked to be a subclass of the given package.

Note: This "type" is in a state of development flux and might be made complete with L<issue
#32|https://github.com/sanko/Affix.pm/issues/32>

=head2 C<Any>

Anything you dump here will be passed along unmodified. We hand off a pointer to the C<SV*> perl gives us without
copying it.

=head2 C<Enum[ ... ]>

The value of an C<Enum> is defined by its underlying type which includes C<Int>, C<Char>, etc.

This type is declared with an list of strings.

    Enum[ 'ALPHA', 'BETA' ];
    # ALPHA = 0
    # BETA  = 1

Unless an enumeration constant is defined in an array reference, its value is the value one greater than the value of
the previous enumerator in the same enumeration. The value of the first enumerator (if it is not defined) is zero.

    Enum[ 'A', 'B', [C => 10], 'D', [E => 1], 'F', [G => 'F + C'] ];
    # A = 0
    # B = 1
    # C = 10
    # D = 11
    # E = 1
    # F = 2
    # G = 12

    Enum[ [ one => 'a' ], 'two', [ 'three' => 'one' ] ]
    # one   = a
    # two   = b
    # three = a

As you can see, enum values may allude to earlier defined values and even basic arithmetic is supported.

Additionally, if you C<typedef> the enum into a given namespace, you may refer to elements by name. They are defined as
dualvars so that works:

    typedef color => Enum[ 'RED', 'GREEN', 'BLUE' ];
    print color::RED();     # RED
    print int color::RED(); # 0

=head2 C<IntEnum[ ... ]>

Same as C<Enum>.

=head2 C<UIntEnum[ ... ]>

C<Enum> but with unsigned integers.

=head2 C<CharEnum[ ... ]>

C<Enum> but with signed chars.

=head1 Typedefs 

...

=head2 C<String>

Char pointers (C<Pointer[Char]>) might be better expressed with C<String> for clarity's sake.

=head2 C<WString>


=head1 LICENSE

Copyright (C) Sanko Robinson.

This library is free software; you can redistribute it and/or modify it under the terms found in the Artistic License
2. Other copyrights, terms, and conditions may apply to data transmitted through this module.

=head1 AUTHOR

Sanko Robinson E<lt>sanko@cpan.orgE<gt>

=begin stopwords

dyncall rvalue enum dualvars dereferencing

=end stopwords

=cut
